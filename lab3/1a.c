/*
A parent process P generates two children processes C1 and C2.
C1 and P communicate through a pipe p1 and C2 and P communicate
through a pipe p2.
- Process C1:
  every WAIT_TIME_1 seconds generates a string of STR_SIZE small alphabetic
  letters at most (i.e., from 1 to STR_SIZE letters) and writes the string
  into pipe p1.
  Overall C1 generates and writes on pipe p1, STR_NUM strings of variable length.
- Process C2:
  does the same things done by C1 but it waits for WAIT_TIME_2
  seconds, and it writes the strings into pipe p2.
- Process P:
  reads the strings coming from the two pipes (p1 and p2), converts
  them in capital letters, and displays them on standard output.

Note that:
- WAIT_TIME_1, WAIT_TIME_2, STR_NUM, and STR_SIZE are predefined
  constant values.
- Strings are randomly generated (composed by only small alphabetic
  letters) of variable length.

Write 4 versions of the program:

A. Using blocking I/O system calls.
B. Using non-blocking I/O system calls.
C. Using multiplexing I/O.
D. Using asynchronous I/O.

Analyze and compare the outputs generated by the different versions of
the program.

Suggestion
----------

Processes C1 and C2 write strings of variable *length* on pipes p1 and
p2, respectively.
To let the parent process P to read these strings "synchronously", it is
better to use the following simple communication protocol:
- C1 and C2, before writing the string onto the pipe, write its length,
  i.e., a single integer value.
- P reads the integer value n and then it reads exactly n characters
  (thus it synchronizes its reading operation with the writing operation
  on the other end of the pipe).
The alternative would be to read from the pipe character-by-character
until finding the termination character of each string ('\0').
*/

#include "1a.h"
#include <sys/wait.h>

int main(){
    int **pipes = generate_and_activate_pipes();
    pid_t pid1, pid2;
    if((pid1 = fork()) > 0){
        if((pid2 = fork()) > 0){
            P(pipes[0], pipes[1]);  // P
            wait((int *) 0);
            wait((int *) 0);
            free_pipes(pipes);
            free(pipes);
        }else
            C(pipes[1], WAIT_TIME_2);   // C2
    }else
        C(pipes[0], WAIT_TIME_1);   // C1
    return 0;
}
