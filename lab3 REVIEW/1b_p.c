/*Exercise 01 (version A, B, C, ad D)
I/O: Blocking, non-blocking, multiplexed, asynchronous
------------------------------------------------------

A parent process P generates two children processes C1 and C2.
C1 and P communicate through a pipe p1 and C2 and P communicate
through a pipe p2.
- Process C1:
  every WAIT_TIME_1 seconds generates a string of STR_SIZE small alphabetic
  letters at most (i.e., from 1 to STR_SIZE letters) and writes the string
  into pipe p1.
  Overall C1 generates and writes on pipe p1, STR_NUM strings of variable length.
- Process C2:
  does the same things done by C1 but it waits for WAIT_TIME_2
  seconds, and it writes the strings into pipe p2.
- Process P:
  reads the strings coming from the two pipes (p1 and p2), converts
  them in capital letters, and displays them on standard output.

Note that:
- WAIT_TIME_1, WAIT_TIME_2, STR_NUM, and STR_SIZE are predefined
  constant values.
- Strings are randomly generated (composed by only small alphabetic
  letters) of variable length.

Write 4 versions of the program:

A. Using blocking I/O system calls.
B. Using non-blocking I/O system calls.
C. Using multiplexing I/O.
D. Using asynchronous I/O.

Analyze and compare the outputs generated by the different versions of
the program.

Suggestion
----------

Processes C1 and C2 write strings of variable *length* on pipes p1 and
p2, respectively.
To let the parent process P to read these strings "synchronously", it is
better to use the following simple communication protocol:
- C1 and C2, before writing the string onto the pipe, write its length,
  i.e., a single integer value.
- P reads the integer value n and then it reads exactly n characters
  (thus it synchronizes its reading operation with the writing operation
  on the other end of the pipe).
The alternative would be to read from the pipe character-by-character
until finding the termination character of each string ('\0').*/


#include "1b.h"
#include <time.h>
#include <fcntl.h>
#include <errno.h>

#define bool int
#define true 1
#define false 0

char *generate_random_message(int *l);
void set_fnctl(int, int);
void clear_fnctl(int, int);

void initialize_pipes(int ***pipes){
    int i;
    *pipes = (int **) malloc(2 * sizeof(int *));
    for(i = 0; i < 2; i++){
        (*pipes)[i]= (int *) malloc(2 * sizeof(int));
        pipe((*pipes)[i]);
    }
}

void C(int *pipe, int wait_time){
    close(pipe[READING_END]);
    int counter = 0;
    while(counter < STR_NUM){
        int l;
        char *message = generate_random_message(&l);
        write(pipe[1], &l, sizeof(int)) > 0);
        fprintf(stdout, "\nC%d -{%d}[%d]-> P\n", wait_time == WAIT_TIME_1 ? 1 : 2, pipe[1], l);
        write(pipe[1], message, l * sizeof(char)) > 0;
        fprintf(stdout, "\nC%d -{%d}[%s]-> P\n", wait_time == WAIT_TIME_1 ? 1 : 2, pipe[1], message);
        counter++;
        sleep(wait_time);
    }
}

void P(int **pipes){
    close(pipes[PIPE1][WRITING_END]);
    close(pipes[PIPE2][WRITING_END]);
    int counter = 0;
    int l1, l2;
    char *message11;
    char *message12;
    char *message21;
    char *message22;
    int left_to_write1;
    int left_to_write2;
    set_fnctl(pipes[PIPE1][READING_END], O_NONBLOCK);
    set_fnctl(pipes[PIPE2][READING_END], O_NONBLOCK);
    //set_fnctl(STDOUT_FILENO, O_NONBLOCK);
    bool polling;
    int states[2];
    while(counter < STR_NUM){
      polling = true;
      state[PIPE1] = -2;
      state[PIPE2] = -2;
      while(polling){
        if(state[PIPE1] < 1)
          state[PIPE1] = polling_pipe1(state[PIPE1], &l1, &message11, &message12, &left_to_write1);
        if(state[PIPE2] < 1)
          state[PIPE2] = polling_pipe2(state[PIPE2], &l2, &message21, &message22, &left_to_write2);
        if(state[PIPE1] == 1 and state[PIPE2] == 1)
          polling = false;
      }
      counter++;
    }
    clear_fnctl(pipes[PIPE1][READING_END], O_NONBLOCK);
    clear_fnctl(pipes[PIPE2][READING_END], O_NONBLOCK);
    //clear_fnctl(STDOUT_FILENO, O_NONBLOCK);
}

int polling_pipe1(int state, int *l, char **message, char **message2, int *left_to_write){
  if(state == -2){
    if(read(pipes[PIPE1][READING_END], l, sizeof(int)) > 0){
      //fprintf(stdout, "\nP <-{%d}[%d]- C1\n", pipes[PIPE1][READING_END], l);
      *left_to_write = *l;
      state++;
    }
  }
  if(state == -1){
    *message = (char *) malloc(*l * sizeof(char));
    if(read(pipes[PIPE1][READING_END], *message, *l * sizeof(char)) > 0){
      //fprintf(stdout, "\nP <-{%d}[%s]- C1", pipes[PIPE1][READING_END], message);
      state++;
    }
  }
  if(state == 0){
    *message2 = (char *) malloc(*l * sizeof(char));
    for(int i = 0; i < *l; i++)
      (*message2)[i] = (*message)[i] - 32;
    int written = write(STDOUT_FILENO, *message2, *l);
    *left_to_write = *left_to_write - written;
    if *left_to_write == 0:
      state++;
  }
  return state;
}

int polling_pipe2(int state){
  if(read(pipes[PIPE2][READING_END], &l2, sizeof(int)) > 0){
    fprintf(stdout, "\nP <-{%d}[%d]- C2\n", pipes[PIPE2][READING_END], l2);
    message2 = (char *) malloc(l * sizeof(char));
    if(read(pipes[PIPE2][READING_END], message2, l2 * sizeof(char))){
      fprintf(stdout, "\nP <-{%d}[%s]- C2\nP -{STDOUT}[", pipes[PIPE2][READING_END], message2);
      for(i2 = 0; i2 < l2; i2++)
          fprintf(stdout, "%c", (char) (*(message2 + i2) - 32));
      fprintf(stdout, "]-> SCREEN\n");
    }
  }
  return state;
}

char *generate_random_message(int *l){
    srand(time(0));
    *l = 1 + (rand() % STR_SIZE);
    char *message = (char *) malloc(*l * sizeof(char));
    int i;
    for(i = 0; i < *l; i++)
        message[i] = 97 + rand() % 26;
    return message;
}

void set_fnctl(int file_id, int flags){
    int val = fcntl(file_id, F_GETFL, 0);
    val = val | flags;
    fcntl(file_id, F_SETFL, val);
}

void clear_fnctl(int file_id, int flags){
    int val = fcntl(file_id, F_GETFL, 0);
    val = val & flags;
    fcntl(file_id, F_SETFL, val);
}
