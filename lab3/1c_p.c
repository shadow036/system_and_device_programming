/*
Exercise 01 (version A, B, C, ad D)
I/O: Blocking, non-blocking, multiplexed, asynchronous
------------------------------------------------------

A parent process P generates two children processes C1 and C2.
C1 and P communicate through a pipe p1 and C2 and P communicate
through a pipe p2.
- Process C1:
  every WAIT_TIME_1 seconds generates a string of STR_SIZE small alphabetic
  letters at most (i.e., from 1 to STR_SIZE letters) and writes the string
  into pipe p1.
  Overall C1 generates and writes on pipe p1, STR_NUM strings of variable length.
- Process C2:
  does the same things done by C1 but it waits for WAIT_TIME_2
  seconds, and it writes the strings into pipe p2.
- Process P:
  reads the strings coming from the two pipes (p1 and p2), converts
  them in capital letters, and displays them on standard output.

Note that:
- WAIT_TIME_1, WAIT_TIME_2, STR_NUM, and STR_SIZE are predefined
  constant values.
- Strings are randomly generated (composed by only small alphabetic
  letters) of variable length.

Write 4 versions of the program:

A. Using blocking I/O system calls.
B. Using non-blocking I/O system calls.
C. Using multiplexing I/O.
D. Using asynchronous I/O.

Analyze and compare the outputs generated by the different versions of
the program.

Suggestion
----------

Processes C1 and C2 write strings of variable *length* on pipes p1 and
p2, respectively.
To let the parent process P to read these strings "synchronously", it is
better to use the following simple communication protocol:
- C1 and C2, before writing the string onto the pipe, write its length,
  i.e., a single integer value.
- P reads the integer value n and then it reads exactly n characters
  (thus it synchronizes its reading operation with the writing operation
  on the other end of the pipe).
The alternative would be to read from the pipe character-by-character
until finding the termination character of each string ('\0').
*/

#include "1c.h"
#include <time.h>
#include <sys/select.h>

#define STR_SIZE 10
#define STR_NUM 5

#define READING_END 0
#define WRITING_END 1

char *generate_random_string(int *);
int find_max(int, int);
void convert_and_print(char *, int l);

void initialize_pipes(int ***pipes){
    *pipes = (int **) malloc(2 * sizeof(int *));
    for(int i = 0; i < 2; i++){
        (*pipes)[i] = (int *) malloc(2 * sizeof(int));
        pipe((*pipes)[i]);
    }
}

void C(int *pipe, int wait_time){
    close(pipe[READING_END]);
    int counter = 0;
    int l;
    char *s;
    while(counter < STR_NUM){
        s = generate_random_string(&l);
        write(pipe[WRITING_END], &l, sizeof(int));
        write(pipe[WRITING_END], s, l * sizeof(char));
        counter++;
        sleep(wait_time);
    }
}

void P(int **pipes){
    close(pipes[PIPE1][WRITING_END]);
    close(pipes[PIPE2][WRITING_END]);
    int counter = 0;
    int l;
    char *message;
    int chosen = -1;
    while(counter < 2 * STR_NUM){
        chosen = -1;
        fd_set reading_set;
        struct timeval waiting_time;
        waiting_time.tv_sec = 0;
        waiting_time.tv_usec = 500000;
        FD_ZERO(&reading_set);
        FD_SET(pipes[PIPE1][READING_END], &reading_set);
        FD_SET(pipes[PIPE2][READING_END], &reading_set);
        select(find_max(pipes[PIPE1][READING_END], pipes[PIPE2][READING_END]) + 1, &reading_set, NULL, NULL, &waiting_time);
        if(FD_ISSET(pipes[PIPE1][READING_END], &reading_set))
            chosen = PIPE1;
        else if (FD_ISSET(pipes[PIPE2][READING_END], &reading_set))
            chosen = PIPE2;
        if(chosen != -1){
            read(pipes[chosen][READING_END], &l, sizeof(int));
            message = (char *) malloc(l * sizeof(char));
            read(pipes[chosen][READING_END], message, l * sizeof(char));
            convert_and_print(message, l);
            counter++;
        }
    }
}

char *generate_random_string(int *l){
    srand(time(0));
    *l = 1 + (rand() % STR_SIZE);
    char *s = (char *) malloc(*l * sizeof(char));
    for(int i = 0; i < *l; i++)
        s[i] = 97 + (rand() % 26);
    return s;
}

void convert_and_print(char *message, int l){
    fprintf(stdout, "\n");
    for(int i = 0; i < l; i++)
        fprintf(stdout, "%c", message[i] - 32);
    fprintf(stdout, "\n");
}

int find_max(int p1, int p2){
    if(p1 > p2)
        return p1;
    else
        return p2;
}
